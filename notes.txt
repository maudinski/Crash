just build it with everything in mind, fuck this "add features as you go" shit, it
just leads to massive spaghetti code

also, haven't tested the lexer with tossing bugs in it

kind of want to have some sort of universal type at the top of all types called VOID or NULL
or something, where you can set any type equal to VOID or NULL or NIL (prolly nil)
might not be a universal type, but a universal value that all types can be set to, not just
pointers. Only problem is that would lead to some weird errors for user

need to be counting newline tokens. If I tie each token (in the lexer) to the line
it's on, then build these ast's with said tokens, it would be easy to know which
line i'm on always, even during sematic analysis. That way I only have to bother
with newlines in the lexer. Might have to change the way I do some shit but could
be worse

i don't need to be using make, i cant just be saying somestruct.somelice = []sometype

function return types have to be after the prototype header shit. Because of the way I'm
doing the lexer

I'm probably writing pretty inefficient code by never returning pointers. Using
new() would allocate memory but return an 8 byte pointer as opposed (apposed?) to
an entire struct. Not sure though, cause there's a trade off with garbage collection

If blocks only consisting of statements becomes a problem for function calls, i can
just make all expressions implement the statement interface too, so they can be out there
on their own. Prefer not to though

a lot of this hasnt been error tested